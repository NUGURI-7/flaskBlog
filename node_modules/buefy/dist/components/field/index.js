/*! Buefy v0.2.0 | MIT License | github.com/buefy/buefy */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
    typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Field = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

    let config = {
      defaultContainerElement: null,
      defaultIconPack: "mdi",
      defaultIconComponent: null,
      defaultIconPrev: "chevron-left",
      defaultIconNext: "chevron-right",
      defaultLocale: void 0,
      defaultDialogConfirmText: null,
      defaultDialogCancelText: null,
      defaultSnackbarDuration: 3500,
      defaultSnackbarPosition: null,
      defaultToastDuration: 2e3,
      defaultToastPosition: null,
      defaultNotificationDuration: 2e3,
      defaultNotificationPosition: null,
      defaultTooltipType: "is-primary",
      defaultTooltipDelay: null,
      defaultTooltipCloseDelay: null,
      defaultSidebarDelay: null,
      defaultInputAutocomplete: "on",
      defaultDateFormatter: null,
      defaultDateParser: null,
      defaultDateCreator: null,
      defaultTimeCreator: null,
      defaultDayNames: null,
      defaultMonthNames: null,
      defaultFirstDayOfWeek: null,
      defaultUnselectableDaysOfWeek: null,
      defaultTimeFormatter: null,
      defaultTimeParser: null,
      defaultDatetimeFormatter: null,
      defaultDatetimeParser: null,
      defaultDatetimeCreator: null,
      defaultClockpickerHoursLabel: null,
      defaultClockpickerMinutesLabel: null,
      defaultColorFormatter: null,
      defaultColorParser: null,
      defaultModalCanCancel: ["escape", "x", "outside", "button"],
      defaultModalScroll: null,
      defaultDatepickerMobileNative: true,
      defaultTimepickerMobileNative: true,
      defaultTimepickerMobileModal: true,
      defaultNoticeQueue: true,
      defaultInputHasCounter: true,
      defaultCompatFallthrough: true,
      defaultTaginputHasCounter: true,
      defaultUseHtml5Validation: true,
      defaultDropdownMobileModal: true,
      defaultFieldLabelPosition: null,
      defaultDatepickerYearsRange: [-100, 10],
      defaultDatepickerNearbyMonthDays: true,
      defaultDatepickerNearbySelectableMonthDays: false,
      defaultDatepickerShowWeekNumber: false,
      defaultDatepickerWeekNumberClickable: false,
      defaultDatepickerMobileModal: true,
      defaultTrapFocus: true,
      defaultAutoFocus: true,
      defaultButtonRounded: false,
      defaultSwitchRounded: true,
      defaultCarouselInterval: 3500,
      defaultTabsExpanded: false,
      defaultTabsAnimated: true,
      defaultTabsType: null,
      defaultStatusIcon: true,
      defaultProgrammaticPromise: false,
      defaultLinkTags: [
        "a",
        "button",
        "input",
        "router-link",
        "nuxt-link",
        "n-link",
        "RouterLink",
        "NuxtLink",
        "NLink"
      ],
      defaultImageWebpFallback: null,
      defaultImageLazy: true,
      defaultImageResponsive: true,
      defaultImageRatio: null,
      defaultImageSrcsetFormatter: null,
      defaultBreadcrumbTag: "a",
      defaultBreadcrumbAlign: "is-left",
      defaultBreadcrumbSeparator: "",
      defaultBreadcrumbSize: "is-medium",
      customIconPacks: null
    };

    function isTag(vnode) {
      return vnode.type !== vue.Comment && vnode.type !== vue.Text && vnode.type !== vue.Static;
    }

    var _sfc_main$1 = vue.defineComponent({
      name: "BFieldBody",
      inject: {
        parent: {
          from: "BField",
          default: null
        }
      },
      props: {
        message: {
          type: [String, Array]
        },
        type: {
          type: [String, Object]
        }
      },
      render() {
        let first = true;
        let children = typeof this.$slots.default === "function" ? this.$slots.default() : this.$slots.default;
        if (children != null && children.length === 1 && children[0].type === vue.Fragment) {
          children = children[0].children;
        }
        return vue.h(
          "div",
          { class: "field-body" },
          {
            default: () => {
              return children != null && children.map((element) => {
                if (element.type === vue.Comment || element.type === vue.Text) {
                  return element;
                }
                let message;
                if (first) {
                  message = this.message;
                  first = false;
                }
                const parentField = this.parent;
                return vue.h(
                  // parentField.$.type is supposed to be BField
                  // it falls back to `resolveComponent('b-field')`
                  // but won't work unless `BField` is globally registered
                  // should not be a problem as long as `BFieldBody` is properly used
                  parentField ? parentField.$.type : vue.resolveComponent("b-field"),
                  {
                    type: this.type,
                    message
                  },
                  () => element
                );
              });
            }
          }
        );
      }
    });

    var _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };

    var BFieldBody = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "/home/runner/work/buefy-next/buefy-next/packages/buefy-next/src/components/field/FieldBody.vue"]]);

    const Field$1 = vue.defineComponent({
      name: "BField",
      components: { BFieldBody },
      provide() {
        return {
          BField: this
        };
      },
      inject: {
        parent: {
          from: "BField",
          default: false
        }
      },
      // Used internally only when using Field in Field
      props: {
        type: {
          type: [String, Object],
          default: void 0
        },
        label: String,
        labelFor: String,
        message: {
          type: [String, Array, Object],
          default: void 0
        },
        grouped: Boolean,
        groupMultiline: Boolean,
        position: String,
        expanded: Boolean,
        horizontal: Boolean,
        addons: {
          type: Boolean,
          default: true
        },
        customClass: String,
        labelPosition: {
          type: String,
          default: () => {
            return config.defaultFieldLabelPosition;
          }
        }
      },
      data() {
        return {
          newType: this.type,
          newMessage: this.message,
          fieldLabelSize: null,
          numberInputClasses: [],
          _isField: true
          // Used internally by Input and Select
        };
      },
      computed: {
        rootClasses() {
          return [
            {
              "is-expanded": this.expanded,
              "is-horizontal": this.horizontal,
              "is-floating-in-label": this.hasLabel && !this.horizontal && this.labelPosition === "inside",
              "is-floating-label": this.hasLabel && !this.horizontal && this.labelPosition === "on-border"
            },
            this.numberInputClasses
          ];
        },
        innerFieldClasses() {
          return [
            this.fieldType(),
            this.newPosition,
            {
              "is-grouped-multiline": this.groupMultiline
            }
          ];
        },
        hasInnerField() {
          return this.grouped || this.groupMultiline || this.hasAddons();
        },
        /*
        * Correct Bulma class for the side of the addon or group.
        *
        * This is not kept like the others (is-small, etc.),
        * because since 'has-addons' is set automatically it
        * doesn't make sense to teach users what addons are exactly.
        */
        newPosition() {
          if (this.position === void 0)
            return;
          const position = this.position.split("-");
          if (position.length < 1)
            return;
          const prefix = this.grouped ? "is-grouped-" : "has-addons-";
          if (this.position)
            return prefix + position[1];
          return void 0;
        },
        /*
        * Formatted message in case it's an array
        * (each element is separated by <br> tag)
        */
        formattedMessage() {
          const parentField = this.parent;
          if (parentField && parentField.hasInnerField) {
            return "";
          }
          if (typeof this.newMessage === "string") {
            return [this.newMessage];
          }
          const messages = [];
          if (Array.isArray(this.newMessage)) {
            this.newMessage.forEach((message) => {
              if (typeof message === "string") {
                messages.push(message);
              } else {
                for (const key in message) {
                  if (message[key]) {
                    messages.push(key);
                  }
                }
              }
            });
          } else {
            for (const key in this.newMessage) {
              if (this.newMessage[key]) {
                messages.push(key);
              }
            }
          }
          return messages.filter((m) => !!m);
        },
        hasLabel() {
          return this.label || this.$slots.label;
        },
        hasMessage() {
          const parentField = this.parent;
          return (!parentField || !parentField.hasInnerField) && this.newMessage || this.$slots.message;
        }
      },
      watch: {
        /*
        * Set internal type when prop change.
        */
        type(value) {
          this.newType = value;
        },
        /*
        * Set internal message when prop change.
        */
        message(value) {
          if (JSON.stringify(value) !== JSON.stringify(this.newMessage)) {
            this.newMessage = value;
          }
        },
        /*
        * Set parent message if we use Field in Field.
        */
        newMessage(value) {
          const parentField = this.parent;
          if (parentField && parentField.hasInnerField) {
            if (!parentField.type) {
              parentField.newType = this.newType;
            }
            if (!parentField.message) {
              parentField.newMessage = value;
            }
          }
        }
      },
      methods: {
        /*
        * Field has addons if there are more than one slot
        * (element / component) in the Field.
        * Or is grouped when prop is set.
        * Is a method to be called when component re-render.
        */
        fieldType() {
          if (this.grouped)
            return "is-grouped";
          if (this.hasAddons())
            return "has-addons";
        },
        hasAddons() {
          let renderedNode = 0;
          if (this.$slots.default) {
            renderedNode = this.$slots.default().reduce((i, node) => isTag(node) ? i + 1 : i, 0);
          }
          return renderedNode > 1 && this.addons && !this.horizontal;
        },
        // called by a number input if it is a direct child.
        wrapNumberinput({ controlsPosition, size }) {
          const classes = ["has-numberinput"];
          if (controlsPosition) {
            classes.push(`has-numberinput-${controlsPosition}`);
          }
          if (size) {
            classes.push(`has-numberinput-${size}`);
          }
          this.numberInputClasses = classes;
        }
      },
      mounted() {
        if (this.horizontal) {
          const elements = this.$el.querySelectorAll(".input, .select, .button, .textarea, .b-slider");
          if (elements.length > 0) {
            this.fieldLabelSize = "is-normal";
          }
        }
      }
    });
    var _sfc_main = Field$1;

    const _hoisted_1 = ["for"];
    const _hoisted_2 = ["for"];
    const _hoisted_3 = {
      key: 3,
      class: "field-body"
    };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_field_body = vue.resolveComponent("b-field-body");
      const _component_b_field = vue.resolveComponent("b-field");
      return vue.openBlock(), vue.createElementBlock(
        "div",
        {
          class: vue.normalizeClass(["field", _ctx.rootClasses])
        },
        [
          _ctx.horizontal ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(["field-label", [_ctx.customClass, _ctx.fieldLabelSize]])
            },
            [
              _ctx.hasLabel ? (vue.openBlock(), vue.createElementBlock("label", {
                key: 0,
                for: _ctx.labelFor,
                class: vue.normalizeClass([_ctx.customClass, "label"])
              }, [
                _ctx.$slots.label ? vue.renderSlot(_ctx.$slots, "label", { key: 0 }) : (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.label),
                      1
                      /* TEXT */
                    )
                  ],
                  64
                  /* STABLE_FRAGMENT */
                ))
              ], 10, _hoisted_1)) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )) : (vue.openBlock(), vue.createElementBlock(
            vue.Fragment,
            { key: 1 },
            [
              _ctx.hasLabel ? (vue.openBlock(), vue.createElementBlock("label", {
                key: 0,
                for: _ctx.labelFor,
                class: vue.normalizeClass([_ctx.customClass, "label"])
              }, [
                _ctx.$slots.label ? vue.renderSlot(_ctx.$slots, "label", { key: 0 }) : (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.label),
                      1
                      /* TEXT */
                    )
                  ],
                  64
                  /* STABLE_FRAGMENT */
                ))
              ], 10, _hoisted_2)) : vue.createCommentVNode("v-if", true)
            ],
            64
            /* STABLE_FRAGMENT */
          )),
          _ctx.horizontal ? (vue.openBlock(), vue.createBlock(_component_b_field_body, {
            key: 2,
            message: _ctx.newMessage ? _ctx.formattedMessage : "",
            type: _ctx.newType
          }, {
            default: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
            /* FORWARDED */
          }, 8, ["message", "type"])) : _ctx.hasInnerField ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3, [
            vue.createVNode(_component_b_field, {
              addons: false,
              type: _ctx.type,
              class: vue.normalizeClass(_ctx.innerFieldClasses)
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["type", "class"])
          ])) : vue.renderSlot(_ctx.$slots, "default", { key: 4 }),
          _ctx.hasMessage && !_ctx.horizontal ? (vue.openBlock(), vue.createElementBlock(
            "p",
            {
              key: 5,
              class: vue.normalizeClass(["help", _ctx.newType])
            },
            [
              _ctx.$slots.message ? vue.renderSlot(_ctx.$slots, "message", {
                key: 0,
                messages: _ctx.formattedMessage
              }) : (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                { key: 1 },
                vue.renderList(_ctx.formattedMessage, (mess, i) => {
                  return vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    [
                      vue.createTextVNode(
                        vue.toDisplayString(mess) + " ",
                        1
                        /* TEXT */
                      ),
                      i + 1 < _ctx.formattedMessage.length ? (vue.openBlock(), vue.createElementBlock("br", { key: i })) : vue.createCommentVNode("v-if", true)
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  );
                }),
                256
                /* UNKEYED_FRAGMENT */
              ))
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      );
    }
    var Field = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "/home/runner/work/buefy-next/buefy-next/packages/buefy-next/src/components/field/Field.vue"]]);

    const registerComponent = (Vue, component, name) => {
      const componentName = name || component.name;
      if (componentName == null) {
        throw new Error("Buefy.registerComponent: missing component name");
      }
      Vue.component(componentName, component);
    };

    const Plugin = {
      install(Vue) {
        registerComponent(Vue, Field);
      }
    };

    exports.BField = Field;
    exports.default = Plugin;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
